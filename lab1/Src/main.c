/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32 VS Code Extension
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>


#define PERIPH_BASE       0x40000000
#define AHB1PERIPH_BASE   (PERIPH_BASE + 0x20000)
#define GPIOC_BASE        (AHB1PERIPH_BASE + 0x0800)
#define GPIOD_BASE        (AHB1PERIPH_BASE + 0x0C00)
#define RCC_BASE          (AHB1PERIPH_BASE + 0x3800)

#define GPIOC             ((GPIO_TypeDef *) GPIOC_BASE)
#define GPIOD             ((GPIO_TypeDef *) GPIOD_BASE)
#define RCC               ((RCC_TypeDef *) RCC_BASE)

typedef struct {
    volatile uint32_t MODER;
    volatile uint32_t OTYPER;
    volatile uint32_t OSPEEDR;
    volatile uint32_t PUPDR;
    volatile uint32_t IDR;
    volatile uint32_t ODR;
    volatile uint32_t BSRR;
    volatile uint32_t LCKR;
    volatile uint32_t AFRL;
    volatile uint32_t AFRH;
} GPIO_TypeDef;

typedef struct {
    volatile uint32_t CR;
    volatile uint32_t PLLCFGR;
    volatile uint32_t CFGR;
    volatile uint32_t CIR;
    volatile uint32_t AHB1RSTR;
    volatile uint32_t AHB2RSTR;
    volatile uint32_t AHB3RSTR;
    uint32_t RESERVED0;
    volatile uint32_t APB1RSTR;
    volatile uint32_t APB2RSTR;
    uint32_t RESERVED1[2];
    volatile uint32_t AHB1ENR;
    volatile uint32_t AHB2ENR;
    volatile uint32_t AHB3ENR;
    uint32_t RESERVED2;
    volatile uint32_t APB1ENR;
    volatile uint32_t APB2ENR;
} RCC_TypeDef;


void init_GPIO() {
    // тактирование портов C и D
    RCC->AHB1ENR |= (1 << 2) | (1 << 3);
    
    // PC4 - PC11 выходы
    for (int i = 4; i <= 11; i++) {
        GPIOC->MODER &= ~(3 << (i * 2));
        GPIOC->MODER |= (1 << (i * 2));
    }
    
    // PC13 и PD2 входы
    GPIOC->MODER &= ~(3 << (13 * 2));
    GPIOD->MODER &= ~(3 << (2 * 2));
    
}


int main(void)
{

    uint8_t num = 0;

    init_GPIO();

    /* Loop forever */
	for(;;){
        // состояние кнопок
        uint8_t btn_PC13 = !(GPIOC->IDR & (1 << 13));
        uint8_t btn_PD2 = !(GPIOD->IDR & (1 << 2));


        // BLUE
        if(btn_PC13 != 0){
            for(int i = 0; i < 50000; i++);
            btn_PC13 = !(GPIOC->IDR & (1 << 13));
            if(btn_PC13 != 0)
                if(num!=0) 
                {
                    num--;
                    // FIRE!!!
                    print(num);

                }
        }
        // RED
        if(btn_PD2 != 0){
            for(int i = 0; i < 50000; i++);
            btn_PD2 = !(GPIOD->IDR & (1 << 2));
            if(btn_PD2 != 0)
                if(num!=255) 
                {
                    num++;
                    // FIRE!!!
                    print(num);
                }
        }

        

        for(long i = 0; i < 500000; i++);
    }
}

void print(uint8_t num){
    GPIOC->ODR &= ~(0b11111111 << 4);
    GPIOC->ODR |= num << (4);
}